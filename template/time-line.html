<template>
    <div class='rc-panel rc-timeline'>
        <div class='rc-panel__content rc-panel__content--full' data-info='content'>
            <div class='rc-timeline__loading' data-info='loading'>Loading ...</div>
            <div class='rc-timeline__list' data-info='timeline'>
                <!-- timeline-item -->
            </div>
            <div class='rc-timeline__mask display-none' data-info='mask'></div>
        </div>
    </div>
</template>
<script>
w.register(function() {
    var syncedMessages = []
    this.data = {}
    this.actions= {
        init: {
            after: function() {
                this.props.mounted = false
                this.props.latestMessage = null
            }
        },
        mount: {
            after: function() {
                if (!this.props.mounted) {
                    this.fetchData()
                    this.props.mounted = true
                }
            }
        },
        fetchData: {
            method: function(finish) {
                return finish()
            },
            after: function(contents) {
                this.dom.loading.classList.add('display-none')
                if (!contents || !contents[0])
                    return
                this.props.latestMessage = contents[0]
                contents
                .filter(content => {
                    return content.subject !== 'Outgoing Fax'
                })
                .forEach((content, index) => this.addLine(content, false, index * 30))
            }
        },
        updateTimeline: {
            after: function(contents) {
                console.log(contents);
                // FIXME: The action of combining messages should be in service
                contents
                // Avoid duplicated notifications
                .filter(content => syncedMessages.indexOf(content.id) === -1)
                .forEach(content => {
                    if (this.props.latestMessage &&
                        this.props.latestMessage.type === content.type &&
                        this.props.latestMessage.contact.id === content.contact.id) {

                        this.props.latestMessage.others = this.props.latestMessage.others || []
                        content.others = content.others || []
                        content.others.push(this.props.latestMessage)
                        content.others = content.others.concat(this.props.latestMessage.others)
                        this.props.latestMessage.widget.unmount()
                    }
                    this.addLine(content, true)
                    this.props.latestMessage = content
                    syncedMessages.push(content.id)
                })
            }
        },
        addLine: {
            after: function(content, prepend, showingDelay) {
                var parent = this
                var item = w('time-line-item', {
                    data: {
                        ...content,
                        showingDelay
                    },
                    actions: {
                        enter: {
                            after: function() {
                                parent.props.selectedContent = this.props.selectedMessage || this.props.content
                                console.log(this.root.firstChild);
                                
                                var srcDOM = this.root.firstChild
                                enlarge({
                                    srcDOM: srcDOM,
                                    targetDOM: parent.dom.content,
                                    transitionEnd: () => {
                                        parent.enterItem()
                                        this.root.appendChild(srcDOM)
                                        srcDOM.style.width = 'auto'
                                        srcDOM.style.height = 'auto'
                                    }
                                })
                                // parent.enterItem()
                            }
                        }
                    }
                })
                content.widget = item
                item.mount(this.dom.timeline, prepend)
            }
        },
        search: {
            method: function(finish) {
                return finish()
            }
        },
        focusSearchBox: {
            method: function(finish) {
                return finish()
            },
            after: function() {}
        },
        blurSearchBox: {
            method: function(finish) {
                return finish()
            },
            after: function() {}
        },
        switchContent: {
            method: function() {},
            after: function() {}
        },
        enterItem: {
            method: function() {},
            after: function() {}
        }
    }
})


function transition({
    trans,
    layerHozTrans,
    layerVerticalTrans,
    initPosition,
    transitionStart,
    transitionTo,
    createLayer
}) {
    return function({ srcScene, targetScene, srcDOM, targetDOM, transitionEnd }) {
            if (targetScene) targetScene.style.display = 'block'
            let srcRect     = srcDOM.getBoundingClientRect()
            let targetRect  = targetDOM.getBoundingClientRect()
            let src = {
                width: srcDOM.offsetWidth,
                height: srcDOM.offsetHeight,
                left: srcRect.left,
                top: srcRect.top
            }
            let target = {
                width: targetDOM.offsetWidth,
                height: targetDOM.offsetHeight,
                left: targetRect.left,
                top: targetRect.top
            }
            
            let [$layer, $layer2] = createLayer({ src, target })
            let layer = div($layer, { overflow: 'hidden' })
            let layer2 = div($layer2, { position: 'fixed' })
            let clone = div(src, { position: 'static' })
            console.log(window.getComputedStyle(srcDOM).marginTop);
            clone.style.marginBottom =  window.getComputedStyle(srcDOM).marginBottom
            clone.style.marginTop =  window.getComputedStyle(srcDOM).marginTop
            let dom = {
                src: srcDOM,
                target: targetDOM,
                layerHoz: layer,
                layerVertical: layer2
            }
            if (targetScene) targetScene.style.display = 'none'
            document.body.appendChild(layer2)
            srcDOM.parentNode.insertBefore(clone, srcDOM)
            layer2.appendChild(layer)
            layer.appendChild(srcDOM)
            
            srcDOM.style.transition = trans
            layer.style.transition = layerHozTrans
            layer2.style.transition = layerVerticalTrans
            transitionStart({ src, target, layerHoz: $layer, layerVertical: $layer2, dom })
            let callback = function() {
                if (targetScene) targetScene.style.display = 'block'
                layer2.parentNode.removeChild(layer2)
                clone.parentNode.removeChild(clone)
                transitionEnd()
            }
            setTimeout(() => transitionTo(
                callback , { src, target, layerHoz: $layer, layerVertical: $layer2, dom })
            , 17)
        }
}
function div(draft, { overflow = 'inherite', position = 'absolute' }) {
    var div = document.createElement('div')
    div.style.width = `${draft.width}px`
    div.style.height = `${draft.height}px`
    div.style.left = `${draft.left}px`
    div.style.top = `${draft.top}px`
    div.style.position = position
    div.style.overflow = overflow
    return div
}
var enlarge = transition({
    trans: 'all .3s cubic-bezier(0.4, 0.0, 0.2, 1)',
    layerHozTrans: 'all .375s ease-in',
    layerVerticalTrans: 'all .375s ease-out',
    transitionStart({ src, target, layerHoz, layerVertical, dom }) {
        var srcDOM = dom.src
        srcDOM.style.width = `${src.width}px`
        srcDOM.style.height = `${src.height}px`
        srcDOM.style.left = `${src.left - layerHoz.left}px`
        srcDOM.style.top = `${src.top - layerVertical.top}px`
    },
    transitionTo(finish, { src, target, layerHoz, layerVertical, dom }) {
        var srcDOM = dom.src
        setTimeout(function() {
            let endedTransitions = 0
            srcDOM.style.height = layerHoz.height + 'px'
            srcDOM.style.top = 0 + 'px'
            srcDOM.addEventListener('transitionend', function end(e) {
                if (++endedTransitions >= 3) {
                    finish()
                    srcDOM.removeEventListener('transitionend', end)
                }
            })
        }, 30)
        srcDOM.style.width = layerHoz.width + 'px'
        srcDOM.style.left = 0 + 'px'
        dom.layerHoz.style.left = target.left + 'px'
        dom.layerVertical.style.top = target.top + 'px'
    },
    createLayer({ src, target }) {
        return [{
            width: target.width,
            height: target.height,
            left: target.left,
            top: 0,
        }, {
            width: target.width,
            height: target.height,
            left: 0,
            top: src.top,
        }]
    }
})

//# sourceURL=time-line.html
</script>
<style>
@import "src/styles/variables.css";
@import "src/styles/mixins.css";
.rc-timeline {
    > .rc-panel__content {
        overflow: auto;
    }
    &__list {
    }
    &__mask {
        position: absolute;
        width:  100%;
        height: 100%;
        top: 0;
    }
    &__loading {
        @mixin padding-large;
        color: #878787;
        text-align: center;
    }
}
</style>
